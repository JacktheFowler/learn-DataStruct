6.1
longest a
dp[i]=max(dp[i-1]+a[i], a[i])
max(dp[i])
6.2
客栈问题 
枚举 pj=min(pi+(200-(aj-ai))**2) p0=0 a0=0 0<=i<j
6.3
高速公路利润
wj=max(wi+mj, wj-1) mi>=mj-k
6.4 加标点
a vi=OR(vj&dict(sub(j, i))) 0<=j<i
6.5棋子问题 
对于i行某列dp[i]=dp[i-1]+dp[i-2] 要么落子dp[i-1] 要么不落dp[i-2]
6.6加括号问题
dp[i, j, t] 对于构成树结构 式子从i到j目标为k
dp[i, j, t]=OR(OR(dp[i, k, m[t][l]]&dp[k+1, j, n[t][l]])l=1~3) i<=k<j
dp[1, b, a]
6.7最长回文
dp[i, j]
true i>=j
dp[i+1, j-1] dp[i]=dp[j]
false else
中途记录回文串长度
6.8最长共同字串
dp[i, j] 
dp[i+1, j+1]=dp[i, j]+1 s[i]=j[j]
dp[i]!=dp[j] 
dp[i+1, j]=dp[i, j]+1 s[i+1]=j[j]
dp[i, j+1]=dp[i, j]+1 s[j+1]=j[j]
else dp[i+1, j+1]=dp[i, j]
6.9分割数据
d[1..m]为按位置排列的分割点 k为需经过的分割点
dp[i, j, s, t]=min(dp[i, d[k], s, k-1]+dp[d[k+1], j, k+1, s]+l(i, j))r<=k<s
dp[1, n, 1, m]
6.10数人头
dp[i, j]
dp[i, j]=0 j>j
else dp[i, j]=dp[i-1, j-1]*p+dp[i-1, j]*(1-p)
dp[n, k]
6.11三角剖分
dp[i, j]
if k=i+1 dp[i, j]=dp[k, j]+A[k, j]
if k=j-1 dp[i, j]=dp[i, k]+A[i, k]
else dp[i, j]=dp[i, k]+dp[k, j]+A[i, k]+A[k, j]
dp[1, m]
6.13打牌
dp[i, j] i, j为牌顶和牌低在原排队所在位置 i<j
ri=max(dp[i+2, j], dp[i+1, j-1])+h[i]
rj=max(dp[i, j+2], dp[i+1, j-1])+h[j]
dp[i, j]=max(ri, rj)

